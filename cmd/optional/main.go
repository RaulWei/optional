// Optional is a tool that generates 'optional' type wrappers around a given type T.
//
// Typically this process would be run using go generate, like this:
//
//	//go:generate optional -type=Foo
//
// running this command
//
//	optional -type=Foo
//
// in the same directory will create the file optional_foo.go
// containing a definition of
//
//	type OptionalFoo struct {
//		...
//	}
//
// The default type is OptionalT or optionalT (depending on if the type is exported)
// and output file is optional_t.go. This can be overridden with the -output flag.
//
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

var (
	typeName = flag.String("type", "", "type name; must be set")
	output   = flag.String("output", "", "output type and file name; default [o|O]ptional<type> and srcdir/optional_<type>.go")

	funcMap = template.FuncMap{
		"title": strings.Title,
		"first": func(s string) string {
			return strings.ToLower(string(s[0]))
		},
		"unexport": func(s string) string {
			return strings.ToLower(string(s[0])) + string(s[1:])
		},
	}
)

const tmpl = `// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at {{ .Timestamp }}

package {{ .PackageName }}

// {{ .OutputName }} is an optional {{ .TypeName }}
type {{ .OutputName }} struct {
	{{ .TypeName | unexport }} {{ .TypeName }}
	present bool
}

// Empty{{ .OutputName | title }} returns an empty optional.{{ .OutputName }}
func Empty{{ .OutputName | title }}() {{ .OutputName }} {
	return {{ .OutputName }}{}
}

// Of{{ .TypeName | title }} creates an optional.{{ .OutputName }} from a {{ .TypeName }}
func Of{{ .TypeName | title }}({{ .TypeName | first }} {{ .TypeName }}) {{ .OutputName }} {
	return {{ .OutputName }}{ {{ .TypeName | unexport }}: {{ .TypeName | first }}, present: true}
}

// Set sets the {{ .TypeName }} value
func (o *{{ .OutputName }}) Set({{ .TypeName | first }} {{ .TypeName }}) {
	o.{{ .TypeName | unexport }} = {{ .TypeName | first }}
	o.present = true
}

// {{ .TypeName | title }} returns the {{ .TypeName }} value
func (o *{{ .OutputName }}) {{ .TypeName | title }}() {{ .TypeName }} {
	return o.{{ .TypeName | unexport }}
}

// Present returns whether or not the value is present
func (o *{{ .OutputName }}) Present() bool {
	return o.present
}

// OrElse returns the {{ .TypeName }} value or a default value if the value is not present
func (o *{{ .OutputName }}) OrElse({{ .TypeName | first }} {{ .TypeName }}) {{ .TypeName }} {
	if o.present {
		return o.{{ .TypeName | unexport}}
	}
	return {{ .TypeName | first }}
}`

func main() {
	log.SetFlags(0)
	log.SetPrefix("optional: ")
	flag.Parse()

	if len(*typeName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	pkg, err := build.Default.ImportDir(".", 0)
	if err != nil {
		log.Fatal(err)
	}

	var outputName string
	var fileName string

	exported := strings.Title(*typeName) == *typeName

	if len(*output) == 0 {
		// no output specified, use default optional_<type>
		if exported {
			outputName = "Optional" + strings.Title(*typeName)
		} else {
			outputName = "optional" + strings.Title(*typeName)
		}
		fileName = fmt.Sprintf("optional_%s.go", strings.ToLower(*typeName))
	} else {
		outputName = *output
		fileName = strings.ToLower(outputName + ".go")
	}

	t := template.Must(template.New("").Funcs(funcMap).Parse(tmpl))

	data := struct {
		Timestamp   time.Time
		PackageName string
		TypeName    string
		OutputName  string
	}{
		time.Now().UTC(),
		pkg.Name,
		*typeName,
		outputName,
	}

	var buf bytes.Buffer

	err = t.Execute(&buf, data)
	if err != nil {
		log.Fatal(err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile(fileName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}
